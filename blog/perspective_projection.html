<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="blogcontent_style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css"
    integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  <title>Perspective Projection</title>
</head>

<body>
  <header>
        <div class="space-inbetween">
          <h1>Perspective Projection</h1>

          <div class="nav-icons">
            <a href="blog.html">
                <i class="fa-solid fa-house"></i>
            </a>

            <a href="../index.html">
                <i class="fa-solid fa-user"></i>
            </a>

          </div>
        </div>

        <hr>
  </header>

    <main>
      <section>
        <div class="side-by-side-img">
          <div class="img-with-caption">
            <img alt="Figure" src="perspective_view_volume.png">
            <sub>Perspective Projection Frustum</sub>
          </div>

          <div class="img-with-caption">
            <img alt="Figure" src="2d_perspective_frustum.png">
            <sub>Perspective Projection Frustum View From x-axis</sub>
          </div>
        </div>

        <br>

        <p>
          A perspective projection matrix allows you to define an arbitrary viewing volume, or frustum, that will dictate which objects are displayed on the screen
          and apply a perspective affect that makes objects further away appear smaller than closer ones.
          This is carried out through the computations contained within a projection matrix:
          <ul>
            <li>1) Distorting the perspective frustum into a viewing volume that resembles an orthographic projection volume- I think this might include projecting coordinates onto the near plane.</li>
            <li>2) Distorting to the canonical viewing volume by remapping the range to [-1, 1].</li>
            <br>
          </ul>
        <p>
      </section>

      <section>
        <h2>Things to Know Before Diving in: Conventions</h2>
        <hr>

        <p>
          This article is mainly geared towards the commonly used conventions that programmers use 
          when working with OpenGL such as 
          column-major ordering for matrices and RHS(Right Handed System) for coordinate systems.
          So, if you'd like to use the results, just keep in mind that you may need to transpose
          the matrices so they're in row-major ordering instead. Also, if there are any other caveats,
          then they will be discussed in the specific section they apply to. Moreover, it doesn't matter
          which conventions you prefer, just make sure you're consistent with them throughout your program.
        </p>
      </section>

      <section>
        <h2>Projection What?</h2>
        <hr>
        <p>
          The first step in determining how to derive the Perspective Projection matrix is, believe it or not,
          knowing how projection works. You can think of projection as a line starting
          from your eye to a specific point in the scene. This line intersects a plane known as the near
          plane, or image plane, and continues into the scene. Drawing out this concept, we can arrive at something
          that looks like the figures below. Where P is the point in the scene, and P' is the the location of the point
          projected onto the near plane.
        </p>

        <div class="side-by-side-img">
          <img alt="Figure" src="2d_perspective_projection_p_example.png">
          <img alt="Figure" src="2d_perspective_projection_p'_example.png">
        </div>

        <p>
          So how do we determine the coordinates for P'? The slope - though, it is also common to use the law of
          similiar triangles to determine the x and y-values of P'. We know the slope for P is y/z, and since
          our goal is to project this point onto the near plane, we multiply the slope by the z-value at near.
          This looks something like z * (y/z) = P'y. This yields the y-value of P'. A similar process is used to
          obtain the x-value of P'. Now working with the zx-plane, we use the slope x/z and again multiply that
          by the z-value denoted by near, to get z * (x/z) = P'x.
        </p>

        <p>
          Now we know how to determine the x and y-values of the projected point: (n * y)/z and (n * x)/z, where n =
          the near projection plane's z-value. But
          because we also want to deform the Perspective Projection Frustum into the canonical view volume,
          we still need to transform our coordinate values from the range [left, right], [bottom, top], and
          [near, far] to [-1, 1], [-1, 1], and [-1, 1] respectively. Sometimes you will see the equations
          defined as -z * (y/-z) = P'y and -z * (x/-z) = P'x when a LHS is preferred by the developer.
        </p>

        <div class="side-by-side-img">
          <div class="img-with-caption">
            <img alt="Figure" src="perspective_view_volume.png">
            <sub>Perspective Projection Frustum</sub>
          </div>

          <div class="img-with-caption">
            <img alt="Figure" src="canonical_view_volume.png">
            <sub>Canonical View Volume</sub>
          </div>
        </div>
      </section>

      <section>
        <h2>Deforming Perspective Frustum into Canonical View Volume</h2>
        <hr>

          <div class="flexy-container">
          <div class="flex-item">
            <div class="img-with-caption-line">
              <sub>P'x Inequality</sub>
              <img alt="Figure" src="p'x_inequality_negative.png">
            </div>

            <div class="img-with-caption">
              <sub>P'y Inequality</sub>
              <img alt="Figure" src="p'y_inequality_negative.png">
            </div>
          </div>

          </div>

      </section>

      <section>
        <h2>Homogeneous Coordinate Trick</h2>
        <hr>

        <p>
          An important step in understanding how to create the Perspective Projection matrix is learning what role 
          homogeneous coordinates play. Consider the figures below, you wouldn't be able to create a matrix that
          divides the x, y, and z values by the z-value contained within the point vector because there is no way
          to carry over the point vector's z-value into the result. Pay attention to the values underlined in red.
          We can use  homogeneous coordinates to copy over the z-value so we can later perform the division
          by w(OpenGL does this division by w automatically and is known as Perspective Division). 
          And that's how the 4th row of the matrix is derived. 
        </p>

        <p>
          You may see this matrix with the 4th row defined as 0 0 1 0, which would not flip the
          sign of z_eye when carrying it over to w_clip. Again, this is something that is
          dependent upon whether or not you're working with a RHS or LHS- programmer's choice. If
          you're working with a RHS in OpenGL and are not calling this function like so: glDepthFunc(GL_GREATER).
          Then it's likely that you need the Perspective Projection Matrix to flip the sign of z_eye so that the handedness
          of your coordinate system goes from RHS to LHS since the default OpenGL depth test operator is GL_LESS which means
          that fragments with a smaller depth value will be in front of fragments with a larger depth value; the opposite
          is said for GL_GREATER.
        </p>

        <div class="side-by-side-img">
          <img alt="Figure" src="blank_projection_matrix.png">
          <img alt="Figure" src="projection_matrix_4th_row_positive.png">
        </div>

      </section>

      <br>
      <br>
      <br>
      <section>
        <h2>Depth Value Loss</h2>
        <hr>

      </section>

      <section>
        <h2>Depth value range of [0, 1] or [-1, 1]</h2>
        <hr>

        <p>
          Fortunately, this doesn't matter too much with OpenGL since the viewport transform kinda handles it. With OpenGL, you can
          partially define the viewport transform using glViewport(...).
        </p>

      </section>

      <br>
      <br>
      <footer>
        <h4>Additonal Resources</h4>
        <ul>
          <li>
            <a href="https://www.youtube.com/watch?v=U0_ONQQ5ZNM&t=358s">Brendan Galea</a>
          </li>
          <li>
            <a href="https://www.youtube.com/watch?v=1z1S2kQKXDs&t=2453s">Cem Yuksel</a>
          </li>
          <li>
            <a href="https://www.youtube.com/watch?v=1z1S2kQKXDs&t=2453s">Scratchapixel</a>
          </li>
          <li>
            <a href="https://www.youtube.com/watch?v=1z1S2kQKXDs&t=2453s">Songho</a>
          </li>
        </ul>
      </footer>
    </main>

</body>
</html>